<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线性筛</title>
      <link href="/2023/08/20/%E6%95%B0%E8%AE%BA/%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
      <url>/2023/08/20/%E6%95%B0%E8%AE%BA/%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h1><p>筛选出2-N中的全部素数，时间复杂度：$\mathcal{O(n)}$:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,primes[N];</span><br><span class="line"><span class="type">bool</span> pri[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pri[i])pirmes[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;primes[j]*i&lt;=n;j++)&#123;</span><br><span class="line">            pri[i*primes[j]]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2023/08/20/%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2023/08/20/%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂："><a href="#快速幂：" class="headerlink" title="快速幂："></a>快速幂：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="function">ll <span class="title">quick_pow</span><span class="params">(ll a,ll b,ll c)</span><span class="comment">//a的b次方对c取余</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(ans*a)%c;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=(a*a)%c;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2023/08/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="普通线段树模板"><a href="#普通线段树模板" class="headerlink" title="普通线段树模板"></a>普通线段树模板</h1><p>区间查询，区间修改，复杂度都是$\mathcal{O(log_2n)}$</p><p>关于乘法和加法同时存在的线段树，我们讨论是先做加法还是先做乘法：</p><p>1.加法优先：</p><p>设父节点的懒标记为$m$和$a$，子节点的懒标记是$mul$和$add$,则：</p><blockquote><p>{$[(x+add)×mul]+a$}$×m&#x3D;(x+add+a&#x2F;mul)×mul×m$</p></blockquote><p>子节点新的$add$为$add+a&#x2F;mul$,新的$mul$为$mul×m$，若$a&#x2F;mul$不是整数，则下取整则损失精度。</p><p>2.乘法优先:</p><blockquote><p>$(x×mul+add)×m+a&#x3D;x×(mul×m)+(add×m+a)$</p></blockquote><p>子节点新的$add$为$add×m+a$，新的$mul$为$mul×m$</p><p>因此我们需要先做乘法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">ll sum;</span><br><span class="line">ll add;<span class="comment">//加法的懒标记</span></span><br><span class="line">ll mul;<span class="comment">//乘法的懒标记</span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;<span class="comment">//上传</span></span><br><span class="line">tree[i].sum = (tree[i&lt;&lt; <span class="number">1</span>].sum + tree[i &lt;&lt; <span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;<span class="comment">//建树</span></span><br><span class="line">tree[i].l = l;</span><br><span class="line">tree[i].r = r;</span><br><span class="line">tree[i].add = <span class="number">0</span>;</span><br><span class="line">tree[i].mul = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">tree[i].sum = a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(i &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line"><span class="built_in">build</span>(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">push_up</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(node&amp; t, ll m, ll a)</span> </span>&#123;</span><br><span class="line">t.sum = (t.sum * m + (t.r-t.l+<span class="number">1</span>)*a) % p;</span><br><span class="line">t.add = (t.add * m + a) % p;</span><br><span class="line">t.mul = t.mul * m % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;<span class="comment">//下传</span></span><br><span class="line"><span class="built_in">cal</span>(tree[i &lt;&lt; <span class="number">1</span>], tree[i].mul, tree[i].add);</span><br><span class="line"><span class="built_in">cal</span>(tree[i &lt;&lt; <span class="number">1</span>|<span class="number">1</span>], tree[i].mul, tree[i].add);</span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">tree[i].add = <span class="number">0</span>;</span><br><span class="line">tree[i].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r,ll m,ll a)</span> </span>&#123;<span class="comment">//区间修改</span></span><br><span class="line"><span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r) &#123;</span><br><span class="line"><span class="built_in">cal</span>(tree[i], m, a);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">push_down</span>(i);</span><br><span class="line"><span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span>].r &gt;= l)<span class="built_in">add</span>(i &lt;&lt; <span class="number">1</span>, l, r, m,a);</span><br><span class="line"><span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l &lt;= r)<span class="built_in">add</span>(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r,m,a);</span><br><span class="line"><span class="built_in">push_up</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">search</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;<span class="comment">//区间求和</span></span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (tree[i].l &gt;= l &amp;&amp; tree[i].r &lt;= r)<span class="keyword">return</span> tree[i].sum;</span><br><span class="line"><span class="built_in">push_down</span>(i);</span><br><span class="line"><span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span>].r &gt;= l)ans = (ans + <span class="built_in">search</span>(i &lt;&lt; <span class="number">1</span>, l, r))%p;</span><br><span class="line"><span class="keyword">if</span> (tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].l &lt;= r)ans = (ans + <span class="built_in">search</span>(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r))%p;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="type">int</span> op;</span><br><span class="line">cin &gt;&gt; op;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> x, y, k;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, x, y, k, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="type">int</span> x, y, k;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, x, y, <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; <span class="built_in">search</span>(<span class="number">1</span>, x, y) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路</title>
      <link href="/2023/08/20/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/2023/08/20/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>在下面的算法中，我们使用链式前向星来存储图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span><span class="comment">//加边，u起点，v终点，w边权</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> to[++cnt]=v;<span class="comment">//指向</span></span><br><span class="line">    val[cnt]=v;<span class="comment">//权值</span></span><br><span class="line">    nxt[cnt]=h[u];<span class="comment">//与其起点相同的上一条边的编号</span></span><br><span class="line">    h[u]=cnt;<span class="comment">//u为起点的最后一条边的编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://is-ans.oss-cn-qingdao.aliyuncs.com/algorithm/9d29bd1ca2efcdb85d4f9902129f83e.png" alt="9d29bd1ca2efcdb85d4f9902129f83e"></p><h1 id="Djikstra"><a href="#Djikstra" class="headerlink" title="Djikstra"></a>Djikstra</h1><p>(初始版本：时间复杂度为$\mathcal{O(n^2+m)}$)</p><p>其过程概括如下:</p><p>1.将起始点的dis置为0</p><p>2.选择当前未标记点dis最小的一个</p><p>3.对该点的所有边以此进行松弛操作</p><p>4.对该点进行标记</p><p>5.重复2-4步，直到不存在一条从已标记点通往为标记点的连边。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2147483647</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> to[N], nxt[N], h[N], val[N], dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> n, cnt, m, start;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> va)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = v;</span><br><span class="line">    val[cnt] = va;</span><br><span class="line">    nxt[cnt] = h[u];</span><br><span class="line">    h[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)dis[i] = inf;</span><br><span class="line">    dis[start] = <span class="number">0</span>;</span><br><span class="line">    dis[<span class="number">0</span>] = inf;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; dis[u] &gt; dis[i])u = i;</span><br><span class="line">        &#125;<span class="comment">//寻找下一个要处理的点</span></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = h[u]; j; j = nxt[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ll)dis[u] + val[j] &lt; dis[to[j]])dis[to[j]] = dis[u] + val[j];</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s, e, v;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; e &gt;&gt; v;</span><br><span class="line">        <span class="built_in">addedge</span>(s, e, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用堆优化优化版本:</p><p>​使用小根堆去优化维护dis数组，在每次松弛成功后将被松弛的边的终点和对应dis打包送入堆中，在需要寻找dis最小值的点时将堆顶取出，验证是否被标记即可。</p><p>​需要注意的是此时的时间复杂度为$\mathcal{O(mlog{m})}$,问题来了我们把时间复杂度从n转换成了m表示，此时如果m和n同级，那么这个优化效率会是极大的提升，但是如果m和$n^2$同级，那反倒不如不优化。(n是点数，m是边数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2147483647</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> to[N], nxt[N], h[N], val[N], dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w;<span class="comment">//存储dis点，价值</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> node &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; b.w;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;tmp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>(); <span class="type">int</span> x = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) s = <span class="number">-1</span>; c = <span class="built_in">getchar</span>(); &#125;<span class="comment">//是符号</span></span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>; c = <span class="built_in">getchar</span>(); &#125;<span class="comment">//是数字</span></span><br><span class="line">    <span class="keyword">return</span> x * s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;node&gt;Q;</span><br><span class="line"><span class="type">int</span> n, cnt, m, start;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> va)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = v;</span><br><span class="line">    val[cnt] = va;</span><br><span class="line">    nxt[cnt] = h[u];</span><br><span class="line">    h[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)dis[i] = inf;</span><br><span class="line">    dis[start] = <span class="number">0</span>;</span><br><span class="line">    tmp.v = start;</span><br><span class="line">    tmp.w = <span class="number">0</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(&#123;tmp&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = Q.<span class="built_in">top</span>().v; Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[u])<span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + val[i] &lt; dis[to[i]]) &#123; dis[to[i]] = dis[u] + val[i], tmp.v = to[i], tmp.w = dis[to[i]], Q.<span class="built_in">push</span>(tmp); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s, e, v;</span><br><span class="line">        s = <span class="built_in">read</span>();</span><br><span class="line">        e = <span class="built_in">read</span>();</span><br><span class="line">        v = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(s, e, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h1><p>过程如下:</p><p>1.将起始点的dis置为0并放入队列</p><p>2.选择队列第一个点并删除</p><p>3.对该点的所有边以此进行松弛操作</p><p>4.将第三步松弛成功且不在队列中的点如队列</p><p>5.重复2-4步，直到队列为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 2147483647</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> to[N], nxt[N], h[N], val[N], dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w;<span class="comment">//存储dis点，价值</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> node &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; b.w;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;tmp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>(); <span class="type">int</span> x = <span class="number">0</span>, s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) s = <span class="number">-1</span>; c = <span class="built_in">getchar</span>(); &#125;<span class="comment">//是符号</span></span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>; c = <span class="built_in">getchar</span>(); &#125;<span class="comment">//是数字</span></span><br><span class="line">    <span class="keyword">return</span> x * s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;Q;</span><br><span class="line"><span class="type">int</span> n, cnt, m, start;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> va)</span> </span>&#123;</span><br><span class="line">    to[++cnt] = v;</span><br><span class="line">    val[cnt] = va;</span><br><span class="line">    nxt[cnt] = h[u];</span><br><span class="line">    h[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)dis[i] = inf;</span><br><span class="line">    dis[start] = <span class="number">0</span>;</span><br><span class="line">    vis[start] = <span class="number">1</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[u] + val[i] &lt; dis[to[i]]) &#123;</span><br><span class="line">                dis[to[i]] = dis[u] + val[i]; </span><br><span class="line">                <span class="keyword">if</span> (!vis[to[i]]) &#123; </span><br><span class="line">                    Q.<span class="built_in">push</span>(to[i]); </span><br><span class="line">                    vis[to[i]] = <span class="number">1</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s, e, v;</span><br><span class="line">        s = <span class="built_in">read</span>();</span><br><span class="line">        e = <span class="built_in">read</span>();</span><br><span class="line">        v = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(s, e, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h1><p>(对于Floyd算法就没必要使用前向星了(已经$\mathcal{O(n^3)}$了，回天乏术了属于是)，直接使用邻接矩阵就好了)</p><p>相比于前两个算法的优点是可以搜索全源:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)d[i][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">d[a][b] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">d[b][a] = <span class="built_in">min</span>(d[b][a], c);<span class="comment">//单向图则不加这句,这种min的写法可以去重</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">floyd</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">cout &lt;&lt; d[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最长上升子序列</title>
      <link href="/2023/08/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)/"/>
      <url>/2023/08/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97(LIS)/</url>
      
        <content type="html"><![CDATA[<h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1><p> 对于最长上升子序列的普通版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; a[j])f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通用优化："><a href="#通用优化：" class="headerlink" title="通用优化："></a>通用优化：</h2><p>我们用DP思想来维护一个栈。如果$a_i&gt;a_{i-1}$,则将$a_i$放入栈$s$中。否则，二分查找$s$中大于等于$a_i$的最小的数，并将它替换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r2 = <span class="number">1</span>;</span><br><span class="line">h[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (h[r2] &lt; a[i]) h[++r2] = a[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">*<span class="built_in">lower_bound</span>(h + <span class="number">1</span>, h + r2 + <span class="number">1</span>, a[i])=a[i];<span class="comment">//二分查找s中大于等于a[i]的最小的数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; r2&lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="在特殊要求-a-i"><a href="#在特殊要求-a-i" class="headerlink" title="在特殊要求$a_i&lt;n$时的优化："></a>在特殊要求$a_i&lt;n$时的优化：</h2><p>使用树状数组来统计前缀最大值：$\mathcal{O(nlog_2n)}$</p><p>把$a_j$想象成某个数组下标，$f_j$想象成记录在那个数组里的数字。那现在需要一个这样的数据结构：可以查询那个数组下标不超过$a_i$的所有元素最大值，并且可以支持对某个位置的值修改。简单来说，此时又回到了带修改的区间查询最值问题，只不过这次他是一个求前缀最小值问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> t[N], a[N], r[N], f[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="comment">//更改x为y</span></span><br><span class="line"><span class="keyword">for</span> (; x &lt; N; x += x &amp; (-x))t[x] = <span class="built_in">max</span>(t[x], y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">serach</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; k; k -= k &amp; (-k))ans = <span class="built_in">max</span>(ans, t[k]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; a[i];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">f[i] = <span class="built_in">serach</span>(a[i]) + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">ins</span>(a[i], f[i]);</span><br><span class="line">ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最长公共子序列</title>
      <link href="/2023/08/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97(LCS)%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97(LCS)%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）:"></a>最长公共子序列（LCS）:</h1><h2 id="普通版本："><a href="#普通版本：" class="headerlink" title="普通版本："></a>普通版本：</h2><p>​我们使用数组$f_{i,j}$表示字符串$a$的前$i$个字符和$b$的前$j$个字符的最长公共子序列长度。</p><p>​考虑$f_{i,j}$来源：可以对LCS不产生影响，比如在${f_{i-1,j}}$上加上$a$这个字符，或者在$f_{i,j-1}$加上$b$这个字符，这些单个的新字符无法加入LCS，因此没有影响；也可以对LCS产生影响，比如当字符$a_i$和${b_j}$相等时，可以在$f_{i-1,j-1}$的基础上同时加入$a_i$和${b_j}$这两个字符，此时LCS长度加一，因此得到状态转移方程：</p><blockquote><p>$f_{i,j}&#x3D;\max(f_{i-1,j},f_{i,j-1},(f_{i-1,j-1}+1)*(a_i&#x3D;&#x3D;b_j))$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+ <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[N][N];</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​对于上述版本我们的时间复杂度为$\mathcal{O(n^2)}$</p><h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h2><h3 id="mathcal-O-nlog-2n"><a href="#mathcal-O-nlog-2n" class="headerlink" title="$\mathcal{O(nlog_2n)}$"></a>$\mathcal{O(nlog_2n)}$</h3><p>​（需要使用到树状数组）</p><p>​对于两个排列的LCS，可以使用一个技巧把他转换成LIS（最长上升子序列）：将第二行的数字替换成{$1,2,3,4…..,n$}同时也对第一行做出调整，例如对于样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>​可以转化成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>​可以看到第二行已经有序了，但是由于只做了位置不变的字符替换，两序列的本质没有变这样第一行的任意一个子序列都可以是上下的公共子序列，也对应了原问题的一个公共子序列（位置不变，做逆替换可以得到）。</p><p>​这个操作有多种实现方式，这里通过记录置换{$4,1,3,2,5$}$\rightarrow${$1,2,3,4,5$},再把这个置换应用与第一行来得到新的第一行。</p><p>​接下去，只要尝试优化LIS的$\mathcal{O(n^2)}$算法就能解决这个问题了。回顾LIS的状态转移方程：</p><blockquote><p>$f_i&#x3D;\max_ \limits{j&lt;i且a_j&lt;a_i}f_j+1$</p></blockquote><p>​可以看到max有两个限制，$j&lt;i且a_j&lt;a_i$，如果考虑上升时序，那么在处理$f_i$的时候，所有已知的$a_j$必然在$a_i$前面，也就是说，$j&lt;i$自然满足。</p><p>​把$a_j$想象成某个数组下标，$f_j$想象成记录在那个数组里的数字。那现在需要一个这样的数据结构：可以查询那个数组下标不超过$a_i$的所有元素最大值，并且可以支持对某个位置的值修改。简单来说，此时又回到了带修改的区间查询最值问题，只不过这次他是一个求前缀最小值问题。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> t[N], a[N], r[N], f[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="comment">//更改第x位改为y</span></span><br><span class="line"><span class="keyword">for</span> (; x &lt; N; x += x &amp; (-x))t[x] = <span class="built_in">max</span>(t[x], y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">serach</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; k; k -= k &amp; (-k))ans = <span class="built_in">max</span>(ans, t[k]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">r[s] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">f[i] = <span class="built_in">serach</span>(r[a[i]]) + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">ins</span>(r[a[i]], f[i]);</span><br><span class="line">ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双向搜索</title>
      <link href="/2023/08/04/%E6%90%9C%E7%B4%A2/%E5%8F%8C%E5%90%91%E6%90%9C%E7%B4%A2/"/>
      <url>/2023/08/04/%E6%90%9C%E7%B4%A2/%E5%8F%8C%E5%90%91%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="双向DFS模板"><a href="#双向DFS模板" class="headerlink" title="双向DFS模板"></a>双向DFS模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">check1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] == <span class="number">1</span>) &#123;</span><br><span class="line">sum += a[i];</span><br><span class="line"><span class="keyword">if</span> (sum &gt; v)<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p1[++cnt1]=sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u &gt; m) &#123;</span><br><span class="line"><span class="built_in">check1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++)b[u] = i, <span class="built_in">dfs1</span>(u + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = m + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] == <span class="number">1</span>) &#123;</span><br><span class="line">sum += a[i];</span><br><span class="line"><span class="keyword">if</span> (sum &gt; v)<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p2[++cnt2] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u &gt; n) &#123;</span><br><span class="line"><span class="built_in">check2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++)b[u] = i, <span class="built_in">dfs2</span>(u + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)cin &gt;&gt; a[i];</span><br><span class="line">m = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(m + <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向BFS模板："><a href="#双向BFS模板：" class="headerlink" title="双向BFS模板："></a>双向BFS模板：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> a[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">queue&lt;pair&lt;string, <span class="type">bool</span>&gt;&gt;Q;<span class="comment">//存储状态</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;QS[<span class="number">2</span>];<span class="comment">//存储走的方式</span></span><br><span class="line"><span class="type">int</span> Next[<span class="number">8</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y,string s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">x =  i/ <span class="number">5</span>;</span><br><span class="line">y = i % <span class="number">5</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y,<span class="type">int</span> nx,<span class="type">int</span> ny,string s)</span> </span>&#123;</span><br><span class="line">string s1 = s;</span><br><span class="line"><span class="built_in">swap</span>(s1[x * <span class="number">5</span> + y], s1[nx * <span class="number">5</span> + ny]);</span><br><span class="line"><span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checks</span><span class="params">(string s, pair&lt;string, <span class="type">bool</span>&gt;h)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (QS[h.second ^ <span class="number">1</span>].<span class="built_in">count</span>(s)) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (QS[h.second ^ <span class="number">1</span>][s] + QS[h.second][h.first] + <span class="number">1</span> &lt;= <span class="number">15</span>)</span><br><span class="line">cout &lt;&lt; QS[h.second ^ <span class="number">1</span>][s] + QS[h.second][h.first] + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">QS[h.second][s] = QS[h.second][h.first] + <span class="number">1</span>;</span><br><span class="line">Q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(s, h.second));</span><br><span class="line"><span class="keyword">if</span> (QS[h.second][s] &gt;<span class="number">8</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">string bg=<span class="string">&quot;&quot;</span>, ed=<span class="string">&quot;1111101111002110000100000&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line"><span class="keyword">if</span> (a[i][j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">//x = i, y = j;</span></span><br><span class="line">a[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">bg += a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())Q.<span class="built_in">pop</span>();</span><br><span class="line">QS[<span class="number">0</span>].<span class="built_in">clear</span>();</span><br><span class="line">QS[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">Q.<span class="built_in">push</span>(&#123; bg,<span class="number">0</span> &#125;);</span><br><span class="line">Q.<span class="built_in">push</span>(&#123;ed,<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> it = Q.<span class="built_in">front</span>();</span><br><span class="line">Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> nx, ny;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="built_in">check</span>(x, y, it.first);</span><br><span class="line">nx = x+Next[i][<span class="number">0</span>];</span><br><span class="line">ny =y+ Next[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= <span class="number">5</span> || ny &gt;= <span class="number">5</span>)<span class="keyword">continue</span>;</span><br><span class="line">string s=<span class="built_in">change</span>(x, y, nx, ny, it.first);<span class="comment">//改变函数</span></span><br><span class="line"><span class="built_in">checks</span>(s,it);<span class="comment">//检测函数  传入修改后的函数和对头结点</span></span><br><span class="line"><span class="keyword">if</span> (flag)<span class="keyword">break</span>;<span class="comment">//检测终止</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dacing Links舞蹈链（DLX）</title>
      <link href="/2023/08/04/%E6%90%9C%E7%B4%A2/%E8%88%9E%E8%B9%88%E9%93%BE/"/>
      <url>/2023/08/04/%E6%90%9C%E7%B4%A2/%E8%88%9E%E8%B9%88%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="舞蹈链模板（-DLX-）"><a href="#舞蹈链模板（-DLX-）" class="headerlink" title="舞蹈链模板（$DLX$）"></a>舞蹈链模板（$DLX$）</h1><h2 id="适用问题"><a href="#适用问题" class="headerlink" title="适用问题"></a>适用问题</h2><p>洛谷:<a href="https://www.luogu.com.cn/problem/P4929">$P4929$ 【模板】舞蹈链（$DLX$）舞蹈链</a></p><p>​该模板用于解决精确覆盖类问题(例:填数独等)</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="https://is-ans.oss-cn-qingdao.aliyuncs.com/algorithm/04470bfd26a6c8a43d6cb5d361a351f.png" alt="04470bfd26a6c8a43d6cb5d361a351f"></p><p>​$(a)$</p><p>​我们采用一种双向循环十字链表的数据结构来存储图。</p><p>​对于该数据结构的实现我们采用数组$ d[N] ,u[N] ,l[N] ,r[N]$分别表示每个节点所指向的下,上，左，右四个方位，采用$row[N],col[N]$来记录对应节点的所在行和列，以及$s[N], h[N]$来存储对应列的节点个数以及所在行的头节点，$ans[N]$用于存储最终我们选择的答案。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​主要思路采用$dfs$思想，从列包含“1”最少的那一列开始搜索可以保证搜索的效率,先删除掉该列，代表此列存在有了“1”,但是由于来自这一列的“1”只能有1行，所以需要对这一列的存在1的每一行进行枚举选择并放入$ans$中做记录,因此在枚举过程中需要删掉该行所含有“1”的每一列（代表选择这行时，对应列的位置有了”1“）以及删掉的列的对应行（因为要保证每列只有一个”1“）。</p><p>​为了保证能够恢复某一列及其对应行，我们在删除一列的时候只删除这一列的头节点的左右节点到头节点的链接而不删除该头节点到左右的链接，在删除对应行的时候我们只删除上下节点到该点的链接而不删除该点到上下节点的链接。</p><p>​然后进深度搜索下一层，最后如果所有的列全部被删除掉就代表搜索成功即代表我们找到了答案，直接输出$ans$中存入的行,如果找不到含有“1”的列了但是还有列没被删除就代表没能搜索成功则返回恢复到删除前的模样。</p><p>​例如：在解决图$(a)$所示的样例时，我们先找到包含”1“最小的列，即第$1$列，我们就删除掉第一列及其对应行(前面说了，这样可以保证在选择到这一列有“1”的时候只有$1$行被选中),随后对这一列中包含“1”的每一行进行选择（删除并存入$ans$），如图$(b)$所示红色是被删除节点，蓝色是被删除并待选行，此时对蓝色中每一行枚举，先选择第二行并在$ans$的对应深度记录下来</p><p><img src="https://is-ans.oss-cn-qingdao.aliyuncs.com/algorithm/1690553461295.png" alt="删除第1列"></p><p>​$(b)$</p><p>​随后删除掉第二行中所有含”1“节点的所在列和对应行，如图$(c)$所示,此时所有的红色节点和蓝色节点均被删除，并记录下我们在深度为$0$时选择第二行。</p><p><img src="https://is-ans.oss-cn-qingdao.aliyuncs.com/algorithm/1690553983285.png" alt="1690553983285"></p><p>​$(c)$</p><p>​随后进行更深一层的选择,我们此时选择第”2“列，并删除掉第$3$行及其所包含”1“的列及对应行如图$(d)$中蓝色和红色节点均被删除。</p><p><img src="https://is-ans.oss-cn-qingdao.aliyuncs.com/algorithm/7462d48e0d227bd625a8d2d199ae990.png" alt="7462d48e0d227bd625a8d2d199ae990"></p><p>​$(d)$</p><p>​再进一步枚举的时候我们发现第4列没有”1“了，即代表这种选择方式搜索到了尽头，第四列不能包含“1”了，需要向上回溯。在图$(b)$中我们选择第四行（之前选择第二行搜索失败）继续搜索直到找出答案为止。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>​首先,我们要构建出最初始的链表，初始化第0行表头:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;<span class="comment">//一共m列</span></span><br><span class="line">        l[i]=i<span class="number">-1</span>,r[i]=i+<span class="number">1</span>;</span><br><span class="line">        u[i]=d[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    l[<span class="number">0</span>]=m,r[m]=<span class="number">0</span>;</span><br><span class="line">    cnt=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​其次我们采用逐个插入各个点的方法，每个点按照输入的顺序从左到右从上到下依次插入到对应表的位置，每次插入修改8个边,并使得相应的记录增加:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    row[++cnt]=x,col[cnt]=y;</span><br><span class="line">    s[y]++;</span><br><span class="line">    <span class="comment">//修改上下链接</span></span><br><span class="line">    u[cnt]=u[y];</span><br><span class="line">    d[u[y]]=cnt;</span><br><span class="line">    d[cnt]=y;</span><br><span class="line">    u[y]=cnt;</span><br><span class="line">    <span class="comment">//链接左右点</span></span><br><span class="line">    <span class="comment">//如果本行没有节点</span></span><br><span class="line">    <span class="keyword">if</span>(!h[x])h[x]=l[cnt]=r[cnt]=cnt;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        l[cnt]=l[h[x]];</span><br><span class="line">        r[l[x]]=cnt;</span><br><span class="line">        r[cnt]=h[x];</span><br><span class="line">        l[h[x]]=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​在删除节点所在列及其对应行的时候应当注意只删除周围点到该点的连线而不删除该点到周围点的连线，以便恢复操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    r[l[y]]=r[y];</span><br><span class="line">    l[r[y]]=l[y];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=d[y];i!=y;i=d[i])&#123;<span class="comment">//向下删除</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=r[i];j!=i;j=r[j])&#123;<span class="comment">//向右删除</span></span><br><span class="line">            d[u[j]]=d[j];</span><br><span class="line">            u[d[j]]=u[j];</span><br><span class="line">    s[col[j]]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​恢复对应列及行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">r[l[y]] = y;</span><br><span class="line">l[r[y]] = y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = u[y]; i != y; i = u[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = l[i]; j != i; j = l[j]) &#123;</span><br><span class="line">u[d[j]] = j;</span><br><span class="line">d[u[j]] = j;</span><br><span class="line">s[col[j]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终代码："><a href="#最终代码：" class="headerlink" title="最终代码："></a>最终代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> d[N], u[N], l[N], r[N];</span><br><span class="line"><span class="type">int</span> row[N], col[N];</span><br><span class="line"><span class="type">int</span> s[N], h[N], ans[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">l[i] = i - <span class="number">1</span>, r[i] = i + <span class="number">1</span>;</span><br><span class="line">u[i] = d[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">l[<span class="number">0</span>] = m, r[m] = <span class="number">0</span>;</span><br><span class="line">cnt = m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">row[++cnt] = x, col[cnt] = y;</span><br><span class="line">s[y]++;</span><br><span class="line">u[cnt] = u[y];</span><br><span class="line">d[u[y]] = cnt;</span><br><span class="line">d[cnt] = y;</span><br><span class="line">u[y] = cnt;</span><br><span class="line"><span class="keyword">if</span> (h[x]==<span class="number">0</span>)h[x] = l[cnt] = r[cnt] = cnt;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">l[cnt] = l[h[x]];</span><br><span class="line">r[l[h[x]]] = cnt;</span><br><span class="line">r[cnt] = h[x];</span><br><span class="line">l[h[x]] = cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">r[l[y]] = r[y];</span><br><span class="line">l[r[y]] = l[y];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = d[y]; i != y; i = d[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = r[i]; j != i; j = r[j]) &#123;</span><br><span class="line">d[u[j]] = d[j];</span><br><span class="line">u[d[j]] = u[j];</span><br><span class="line">s[col[j]]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resume</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">r[l[y]] = y;</span><br><span class="line">l[r[y]] = y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = u[y]; i != y; i = u[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = l[i]; j != i; j = l[j]) &#123;</span><br><span class="line">u[d[j]] = j;</span><br><span class="line">d[u[j]] = j;</span><br><span class="line">s[col[j]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dance</span><span class="params">(<span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dep; i++)cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> y = r[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = r[<span class="number">0</span>]; i; i = r[i])<span class="keyword">if</span> (s[i] &lt; s[y])y = i;</span><br><span class="line"><span class="built_in">remove</span>(y);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = d[y]; i != y; i = d[i]) &#123;</span><br><span class="line">ans[dep] = row[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = r[i]; j != i; j = r[j])<span class="built_in">remove</span>(col[j]);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dance</span>(dep + <span class="number">1</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = l[i]; j != i; j = l[j])<span class="built_in">resume</span>(col[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resume</span>(y);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>)<span class="built_in">link</span>(i, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">dance</span>(<span class="number">0</span>))cout &lt;&lt; <span class="string">&quot;No Solution!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过测试："><a href="#通过测试：" class="headerlink" title="通过测试："></a>通过测试：</h2><p><img src="https://is-ans.oss-cn-qingdao.aliyuncs.com/algorithm/c75a72b4b500f9cd1165b49c6c66acc.png" alt="c75a72b4b500f9cd1165b49c6c66acc"></p>]]></content>
      
      
      <categories>
          
          <category> 搜索 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单调队列</title>
      <link href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>​单调队列是一种内部元素具有单调性的队列，可以解决“区间内最值”问题，该算法更适用于解决滑动窗口类问题。</p><p>​例如在解决窗口内最大值时：设窗口长度为k,使用一个队列来维护数据，队首在左，对尾在右,队列中存储的是元素下标。首先队列为空，将元素加入到队列中。如果接下来的元素是比队尾元素更大，那么就将队尾元素出队，直到这个元素不大于队尾元素为止。当处理到的数字编号大于k说明已经处理完了k个数字，就可以查询这个区间的最大值了。这里的最大值是队首元素。</p><p>​每次加入新元素之前，先要检查队首元素是否过期（不在统计需要的区间内）：如果队首元素编号加上k没有超过i，那就说明队首元素过期，此时队首元素出队。</p><p>​例如对于$len为4$的窗口：$3\quad 19\quad 1\quad 12\quad 5\quad 8\quad 10\quad 6$</p><p><img src="https://is-ans.oss-cn-qingdao.aliyuncs.com/algorithm/c8b7e50b7d5428ac6be3ad988b891ab.jpg" alt="c8b7e50b7d5428ac6be3ad988b891ab"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#defien maxn 1000010</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[maxn],q[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> head=<span class="number">0</span>,tail=<span class="number">0</span>;<span class="comment">//tail指向的是最后一个的下一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;q[head]+k<span class="number">-1</span>&lt;i)head++;<span class="comment">//对头元素过期 出队</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;a[q[tail<span class="number">-1</span>]]&lt;a[i])tail--;</span><br><span class="line">        q[tail]=i;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k)cout&lt;&lt;a[q[head]]&lt;&lt;endl;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ST表</title>
      <link href="/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ST%E8%A1%A8/"/>
      <url>/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ST%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h1><h2 id="适用范围："><a href="#适用范围：" class="headerlink" title="适用范围："></a>适用范围：</h2><p>​ST表用于查询区间最值，建表的时间复杂度为$\mathcal {O}(nlog_2n)$,查询的时间复杂度为$\mathcal {O}(1)$,好处是可以快速查询任意区间的最值，缺点是在建表后不可修改表：</p><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>​建立二维数组$st[i][j]$表示在起点为$i$，长度为$2^j$的区间内的最值</p><p>​建表：</p><p><img src="https://is-ans.oss-cn-qingdao.aliyuncs.com/algorithm/a3a27d3feb7a9dd12b7e50ddfb86195.png" alt="初始化"></p><p>​</p><blockquote><p>$f[i][j]&#x3D;min&#x2F;max(f[i][j-1],f[i+1&lt;&lt;(j-1)][j-1])$</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= <span class="number">20</span>; len++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">1</span>; s + (<span class="number">1</span> &lt;&lt; len) - <span class="number">1</span> &lt;= n; s++) &#123;</span><br><span class="line">dp[s][len] = <span class="built_in">max</span>(dp[s][len - <span class="number">1</span>], dp[s + (<span class="number">1</span> &lt;&lt; len - <span class="number">1</span>)][len - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​对于查询操作：</p><p>​先计算出区间长度：</p><blockquote><p>$int\quad len&#x3D;log_2(r-l+1)$</p></blockquote><p>​随后当查询为$[l,r]$时：</p><blockquote><p>$ans&#x3D;max&#x2F;min(st[l][len-1],[r-(1&lt;&lt;len)+1][len-1])$</p></blockquote><h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch<span class="number">-48</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)dp[i][<span class="number">0</span>]=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= <span class="number">20</span>; len++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">1</span>; s + (<span class="number">1</span> &lt;&lt; len) - <span class="number">1</span> &lt;= n; s++) &#123;</span><br><span class="line">dp[s][len] = <span class="built_in">max</span>(dp[s][len - <span class="number">1</span>], dp[s + (<span class="number">1</span> &lt;&lt; len - <span class="number">1</span>)][len - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line"><span class="type">int</span> k = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2023/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2023/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="适用问题："><a href="#适用问题：" class="headerlink" title="适用问题："></a>适用问题：</h2><p>​适用于区间查询和单点修改类题目，时间复杂度均为$\mathcal {O(log_2n)}$.</p><h2 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h2><p>​在开始之前，我们先介绍一个函数$lowbit(x)$,非负整数$n$在二进制表示下的最低为1 及其后面的0构成的数值,因此</p><blockquote><p>​$lowbit(x)$&#x3D;$n$&amp;(~$n+1)$&#x3D;$n$&amp;$-n$</p></blockquote><p>​我们建立这样的树状结构：</p><p>​<img src="https://is-ans.oss-cn-qingdao.aliyuncs.com/algorithm/5da98a5df93755a00b2fbf4e40289b3.png" alt="5da98a5df93755a00b2fbf4e40289b3"></p><p>​$t[x]$表示保存以x为跟的字数中叶节点值的和，因此我们发现$t[x]$节点覆盖的长度是$lowbit(x)$，继续观察,我们发现$t[x]$的父节点为$t[x+lowbit(x)]$, 而且整个数的深度为$log_2n+1$。</p><p>对于其两种操作：</p><p>​1.单点修改：</p><p>​一个点修改那么其以及其父节点向上的所有节点都要修改，类似于前缀和思想：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lowbit</span>(x)) &#123;</span><br><span class="line">t[x] += k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​2:区间查询：</p><p>​例如：查询区间$[L,R]$内的区间和，那就用前$R$项的和减去前$L-1$项的和就是$[L,R]$的区间和：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = y; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">ans += t[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x<span class="number">-1</span>; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">ans -= t[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], t[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lowbit</span>(x)) &#123;</span><br><span class="line">t[x] += k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = y; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">ans += t[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x<span class="number">-1</span>; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">ans -= t[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">add</span>(i, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; c &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">add</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">search</span>(x, y) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/*星空特效*//* 背景宇宙星光  */#universe{  display: block;  position: fixed;  margin: 0;  padding: 0;  border: 0;  outline: 0;  left: 0;  top: 0;  width: 100%;  height: 100%;  pointer-events: none;  /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */  z-index: -1;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/*首页分类的黑夜配饰*//* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 *//* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}/*背景卡片图*//* 个人信息卡片背景图 */[data-theme="light"] #aside-content > .card-widget.card-info {  background-image: url(https://is-ans.oss-cn-qingdao.aliyuncs.com/algorithm/ff9fe15e061395cfb30cb3c7eb8aeef.png);  background-repeat: no-repeat;  background-attachment: inherit;  background-size: 100%;}[data-theme="dark"] #aside-content > .card-widget.card-info {  background-image: url(https://is-ans.oss-cn-qingdao.aliyuncs.com/algorithm/ass.jpg);  background-repeat: no-repeat;  background-attachment: inherit;  background-size: 100%;}/* 头像呼吸灯 */[data-theme="light"] .avatar-img {  animation: huxi_light 4s ease-in-out infinite;}[data-theme="dark"] .avatar-img {  animation: huxi_dark 4s ease-in-out infinite;}@keyframes huxi_light {  0% {    box-shadow: 0px 0px 1px 1px #e9f5fa;  }  50% {    box-shadow: 0px 0px 5px 5px #e9f5fa;  }  100% {    box-shadow: 0px 0px 1px 1px #e9f5fa;  }}@keyframes huxi_dark {  0% {    box-shadow: 0px 0px 1px 1px #39c5bb;  }  50% {    box-shadow: 0px 0px 5px 5px #39c5bb;  }  100% {    box-shadow: 0px 0px 1px 1px #39c5bb;  }}/*猫猫特效*/body::-webkit-scrollbar {  width: 0;}.neko {  width: 64px;  height: 64px;  background-image: url("https://bu.dusays.com/2022/07/20/62d812db74be9.png");  position: absolute;  right: 32px;  background-repeat: no-repeat;  background-size: contain;  transform: translateX(50%);  cursor: pointer;  font-family: tzy;  font-weight: 600;  font-size: 16px;  color: #6f42c1;  display: none;}.neko::after {  display: none;  width: 100px;  height: 100px;  background-image: url("https://bu.dusays.com/2022/07/20/62d812d95e6f5.png");  background-size: contain;  z-index: 9999;  position: absolute;  right: 50%;  text-align: center;  line-height: 100px;  top: -115%;}.neko.showMsg::after {  content: attr(data-msg);  display: block;  overflow: hidden;  text-overflow: ellipsis;}.neko:hover::after {  content: attr(data-msg);  display: block;  overflow: hidden;  text-overflow: ellipsis;}.neko.fontColor::after {  color: #333;}/*** @description: 滚动条样式  跟猫二选一*/@media screen and (max-width:992px) {  ::-webkit-scrollbar {      width: 8px !important;      height: 8px !important  }  ::-webkit-scrollbar-track {      border-radius: 2em;  }  ::-webkit-scrollbar-thumb {      background-color: rgb(255 255 255 / .3);      background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent);      border-radius: 2em  }  ::-webkit-scrollbar-corner {      background-color: transparent  }}/*导航栏魔改*//* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -38px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[var now=new Date;function createtime(){now.setTime(now.getTime()+1e3);var e=new Date("08/01/2022 00:00:00"),t=Math.trunc(234e8+(now-e)/1e3*17),a=(t/1496e5).toFixed(6),o=new Date("08/09/2022 00:00:00"),n=(now-o)/1e3/60/60/24,r=Math.floor(n),i=(now-o)/1e3/60/60-24*r,s=Math.floor(i);1==String(s).length&&(s="0"+s);var d=(now-o)/1e3/60-1440*r-60*s,l=Math.floor(d);1==String(l).length&&(l="0"+l);var g=(now-o)/1e3-86400*r-3600*s-60*l,b=Math.round(g);1==String(b).length&&(b="0"+b);let c="";c=s<18&&s>=9?`<img class='boardsign' src='https://img.shields.io/badge/F小屋-上班摸鱼中-6adea8?style=social&logo=cakephp' title='什么时候能够实现财富自由呀~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>`:`<img class='boardsign' src='https://sourcebucket.s3.ladydaily.com/badge/F小屋-下班休息啦.svg' title='下班了就该开开心心地玩耍~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>`,document.getElementById("workboard")&&(document.getElementById("workboard").innerHTML=c)}setInterval((()=>{createtime()}),1e3);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
  
</search>
